# Код для исследования
```java

public class JvmComprehension {

    public static void main(String[] args) {
        int i = 1;                      // 1
        Object o = new Object();        // 2
        Integer ii = 2;                 // 3
        printAll(o, i, ii);             // 4
        System.out.println("finished"); // 7
    }

    private static void printAll(Object o, int i, Integer ii) {
        Integer uselessVar = 700;                   // 5
        System.out.println(o.toString() + i + ii);  // 6
    }
}

```
## Разбор
 - Class loader
1. На первом этапе называемом "подгрузка" исходный класс будет загружен в ApplicationClassLoader. Далее предстоит последовательная передача класса в Platform ClassLoader и Bootstrap Class loader. Это стандартный путь, который проходят все классы посредством JVM. 
2. При попадании в Bootstrap ClassLoader производится проверка данного класса и объектов входящих в него на принадлежность стандартной библиотеке Java. При нахождении таких классов они загружаются в память посредтвом Bootstrap Class loader-а. Оставшиеся классы передаются в Platform ClassLoader.
3. В Platform ClassLoader проходит проверка класса и оставшихся в нем объектов на вхождение в дополнительных библиотеках, которые могли быть подгружены при помощи сборщиков проекта, либо вручную. При подтверждении вхождения в такие библиотеки Platform ClassLoader осуществляет загрузку таких классов в память, а оставшиеся передает Application Classloader-y.
4. Application ClassLoader производит загрузку в память объектов, созданных вручную. На этом заканчивается первый этап загрузки классов.
5. Далее начинается второй этап загрузки, на котором код подготавливается к выполнению посредством связывания классов. Сначала производится проверка валидности кода, после чего на стадии подготовки инициализируются статические поля классов, затем производится связывание ссылок на другие классы.
6. После производится инициализация классов путем выполнения static инициализаторов и инициализации static полей.
 - Области памяти
1. Metaspase
  В данную область памяти попадают все данные о классе и константы. Ее размер можно изменить.
В ней будет находиться объект класса JvmComprehension и системные классы: Object, Integer, System, String.
2. Stack memory
  В стэк помещается входной метод main(). Вызов дальнейших методов сопровождается созданием в стэке фреймов, в которые помещаются примитивы и ссылки на объекты, которые входят в данные методы. Во время окончания метода наполнение фрейма удаляется. Размер стэка фиксирован.
3. Heap
  Куча вмещает в себя все инициализированные объекты при выполнении кода. Имеет минимальный и максимальный допустимые размеры.
  
  - Сборщик мусора
  При удалении фреймов из стека остаются объекты в куче без ссылок. Их удаление производится посредством сборщика мусора. Объект удаляется при отсутствии у него связей с другими объектами. Сборщик мусора цикличен, если объект проверялся на наличие связей более двух раз, сборщик уже не будет его удалять.
 
 
 ```java
int i = 1; // 1
 ```
 Производится добавление примитивной переменной во фрейм метода main()
```java
Object o = new Object(); // 2
```
  Создается объект "о". Сам объект помещается в кучу, сслыка на него идет во фрейм метода main().
 ```java 
Integer ii = 2; // 3
 ``` 
 Создается объект типа Integer, ссылка на него идет во фрейм метода main(), а сам объект помезается в кучу
```java 
printAll(o, i, ii); // 4
 ```
 Производится вызов метода printAll(), создается фрейм для данного метода, в него помещается ссылки "о" на Object и "ii" на Integer в куче, а также примитивная переменная i.
```java 
Integer uselessVar = 700; // 5
 ```
  Создается объект "uselessVar". Сам объект помещается в кучу, сслыка на него идет во фрейм метода main().
```java 
System.out.println(o.toString() + i + ii); // 6
 ```
 JVM получит информацию о классе System из Mataspace, после чего будет создан новый фрейм в стеке, в который будет передана примитивная переменная i, ccылка на Integer ii, а также ссылка на "Object o", у которого будет вызван метод toString, создастся новый фрейм, в который будет помещена ссылка на Object o. После получения строкового значения "Object o" будет производиться контантенация строковых переменных посредством создания объекта String Builder-a, помещением ссылки Builder-a во фрейм метода println потока out. Далее будут вызваны методы append по ссылке к билдеру, и три строковых объекта будут помещены в "String pool" в куче. Ссылка на "String pool" будет передана во фрейм метода println.
 ```java 
 System.out.println("finished"); // 7
  ```
  Будет создан фрейм метода println, куда будет передана ссылка на строку "finished" из String pool-a в куче.
